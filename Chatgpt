import os
import csv
from collections import defaultdict
from statistics import variance


def find_best_average(values):
    while len(values) > 1:
        avg = sum(values) / len(values)
        var = variance(values)
        if var < 0.05:
            return avg
        else:
            values = values[1:]
    return values[0]

def process_txt_files(network_location, output_file_path):
    fieldnames = ['File_Name', 'eventId', 'EventName']
    for i in range(1, 11):
        fieldnames.extend([f'back_P0_{i}', f'lay_P0_{i}'])

    # Open the output file in 'write' mode
    with open(output_file_path, 'w', newline='') as outfile:
        csv_writer = csv.writer(outfile)
        csv_writer.writerow(fieldnames)

        # Iterate through all files in the network directory
        for filename in os.listdir(network_location):
            if filename.endswith('.txt'):
                txt_file_path = os.path.join(network_location, filename)
                hs_file_directory = 'path_to_hs_files_directory'  # Replace this with the correct directory path for HS files
                events = []

                with open(txt_file_path, 'r') as txtfile:
                    for line in txtfile:
                        event_data = line.strip().split(',')
                        event = {
                            'File_Name': filename,
                            'eventId': event_data[0],
                            'EventName': event_data[1],
                            'back_P0': event_data[2],
                            'lay_P0': event_data[3],
                            'Inplay': event_data[4],
                            # Add other fields as needed based on your txt file format
                        }
                        events.append(event)

                inplay_events = []
                odds_found = 0

                for event in events:
                    if event.get('Inplay') == 'True' and event.get('SelectionId') == '1096':
                        back_P0 = event.get('back_P0')
                        lay_P0 = event.get('lay_P0')

                        if back_P0 and lay_P0:
                            odds_found += 1
                            inplay_events.append({'back_P0': float(back_P0), 'lay_P0': float(lay_P0)})

                        if odds_found == 10:
                            break

                if odds_found == 10:
                    # Calculate the average for back_P0 and lay_P0
                    back_P0_values = [event['back_P0'] for event in inplay_events]
                    lay_P0_values = [event['lay_P0'] for event in inplay_events]
                    back_P0_average = round(sum(back_P0_values) / len(back_P0_values), 2)
                    lay_P0_average = round(sum(lay_P0_values) / len(lay_P0_values), 2)

                    # Write the row to the output file and flush the buffer
                    row_data = [filename, events[0]['eventId'], events[0]['EventName']]
                    for i in range(10):
                        if i < len(back_P0_values):
                            row_data.append(back_P0_values[i])
                            row_data.append(lay_P0_values[i])
                        else:
                            row_data.append('')
                            row_data.append('')
                    row_data.extend([back_P0_average, lay_P0_average])
                    csv_writer.writerow(row_data)
                    outfile.flush()

                print(f"Processed event: {events[0]['EventName']}")

        print("All events have been processed and saved to the CSV file.")

def main():
    network_location = '//NASWDC/Data/Betfair/Soccer/CS'
    output_file_path = os.path.join(network_location, 'outputCS_1096_filtered.csv')

    process_txt_files(network_location, output_file_path)

if __name__ == "__main__":
    main()
